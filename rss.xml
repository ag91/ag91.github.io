<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>Where parallels cross</title>
    <link>http://ag91.github.io</link>
    <description>Interesting bits of life</description>
    <pubDate>Mon, 11 Dec 2023 23:30:50 GMT</pubDate>
    <lastBuildDate>Mon, 11 Dec 2023 23:30:50 GMT</lastBuildDate>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>Org-page static site generator (https://github.com/kelvinh/org-page)</generator>
    <item>
      <title>Make Emacs help in creating an example of Scala classes</title>
      <link>http://ag91.github.io/blog/2023/12/11/make-emacs-help-in-creating-an-example-of-scala-classes</link>
      <description><![CDATA[<div>
<div class="post">
<h1>Make Emacs help in creating an example of Scala classes</h1>
<p>
I recently found myself in need of creating test examples for Scala
case classes. These tend to have quite a lot of nested fields, here an
example of what I am dealing with:
</p>

<div class="org-src-container">
<pre class="src src-scala">case class A(a: Option[Int])
case class B(a: A, b: Boolean)
case class C(b: B, d: Int, e: Double)

C // edit manually, nooo!!
</pre>
</div>

<p>
Now for a test I would need to derive an example of this by hand <sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>.
</p>

<p>
I did that and it is boring. So Emacs to support me!
A little Elisp hack saves the day:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(defun my/s-replace-regexp-all (replacements s)
    "REPLACEMENTS is a list of cons-cells. Each `car` is replaced with `cdr` in S."
    (declare (pure t) (side-effect-free t))
    (if (equal nil replacements)
        s
      (my/s-replace-regexp-all
       (cdr replacements)
       (s-replace-regexp (car (car replacements)) (cdr (car replacements)) s 'fixed-case))))

(defun my/stub-scala-class ()
  (interactive)
  (let ((replacements ;; supported replacements
         '(("Option\\[[A-Za-z]*\\]" . "None") ;; TODO can I generalize these higher order datatypes (e.g., Either?
                        ("List\\[[A-Za-z]*\\]" . "Nil")
                        ("Set\\[[A-Za-z]*\\]" . "Set()")
                        ("String" . "\"someString\"")
                        ("Int" . "123")
                        ("Long" . "123")
                        ("Double" . "123.123")
                        ("Boolean" . "false")
                        (":" . " =") ;; not types anymore, but values
                        ))
        (class
         (save-excursion
           (save-window-excursion
             (let ((s (thing-at-point 'symbol 'no-props)))
               (or
                ;; try to work around xref-find-definitions
                (when-let ((p (save-excursion
                                (goto-char (point-min))
                                (search-forward (concat "class " s) nil t)
                                (- (point) 1))))
                  (and (goto-char p) t))
                ;; use xref (lsp-metals provides this)
                (xref-find-definitions s)))
             (if (equal major-mode 'scala-mode)
                 (progn (search-forward "(")
                        (goto-char (- (point) 1))
                        (thing-at-point 'sexp 'no-props))
               (error "No class to stub at point"))
             ))))
    (goto-char (cdr (bounds-of-thing-at-point 'symbol)))
    (insert (my/s-replace-regexp-all replacements class))
    ))
</pre>
</div>

<p>
If you run this with your cursor on the <code>C</code> above, you will get:
</p>

<div class="org-src-container">
<pre class="src src-scala">C(b = B, d = 123, e = 123.123)
</pre>
</div>

<p>
You can see that it didn't stub <code>B</code>, but we can do it manually:
</p>

<div class="org-src-container">
<pre class="src src-scala">C(b = B(a = A, b = false), d = 123, e = 123.123)
</pre>
</div>

<p>
And one more on the <code>A</code>:
</p>

<div class="org-src-container">
<pre class="src src-scala">C(b = B(a = A(a = None), b = false), d = 123, e = 123.123)
</pre>
</div>

<p>
This is just a hack to speed up my work, so I didn't look into adding
recursion (I must say that it satisfies me to fill manually, maybe
because it also let me familiarize with the data structure for now?)
and only few data types are supported (already <code>Either</code> requires some
manual edits).
</p>

<p>
All in all, it was a useful thought exercise to make Emacs take some
error-prone work away from me :)
</p>

<p>
Happy hacking!
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Sure
I could generated the data with ScalaCheck and do some property based
testing. But here I want to focus on creating a single example.</p></div></div>


</div>
</div>
</div>
</div>]]></description>
      <pubDate>2023-12-11</pubDate>
      <guid>http://ag91.github.io/blog/2023/12/11/make-emacs-help-in-creating-an-example-of-scala-classes</guid>
    </item>
    <item>
      <title>An easier way to try Cljs libraries with shadow-cljs ob-clojure and cider</title>
      <link>http://ag91.github.io/blog/2023/08/28/an-easier-way-to-try-cljs-libraries-with-shadow-cljs-ob-clojure-and-cider</link>
      <description><![CDATA[]]></description>
      <pubDate>2023-08-29</pubDate>
      <guid>http://ag91.github.io/blog/2023/08/28/an-easier-way-to-try-cljs-libraries-with-shadow-cljs-ob-clojure-and-cider</guid>
    </item>
    <item>
      <title>An easier way to try out Clojure libraries with ob-clojure and cider</title>
      <link>http://ag91.github.io/blog/2023/08/03/an-easier-way-to-try-out-clojure-libraries-with-ob-clojure-and-cider</link>
      <description><![CDATA[]]></description>
      <pubDate>2023-08-03</pubDate>
      <guid>http://ag91.github.io/blog/2023/08/03/an-easier-way-to-try-out-clojure-libraries-with-ob-clojure-and-cider</guid>
    </item>
    <item>
      <title>scala-cli-repl: a Scala REPL based on scala-cli</title>
      <link>http://ag91.github.io/blog/2023/07/22/scala-cli-repl-a-scala-repl-based-on-scala-cli</link>
      <description><![CDATA[]]></description>
      <pubDate>2023-07-22</pubDate>
      <guid>http://ag91.github.io/blog/2023/07/22/scala-cli-repl-a-scala-repl-based-on-scala-cli</guid>
    </item>
    <item>
      <title>A little exploration of Go from a Clojure perspective</title>
      <link>http://ag91.github.io/blog/2023/06/08/a-little-exploration-of-go-from-a-clojure-perspective</link>
      <description><![CDATA[]]></description>
      <pubDate>2023-06-08</pubDate>
      <guid>http://ag91.github.io/blog/2023/06/08/a-little-exploration-of-go-from-a-clojure-perspective</guid>
    </item>
    <item>
      <title>ob-gore: literate Go run via the Gore REPL</title>
      <link>http://ag91.github.io/blog/2023/06/06/ob-gore-literate-go-run-via-the-gore-repl</link>
      <description><![CDATA[]]></description>
      <pubDate>2023-06-06</pubDate>
      <guid>http://ag91.github.io/blog/2023/06/06/ob-gore-literate-go-run-via-the-gore-repl</guid>
    </item>
    <item>
      <title>FS2 vs ZIO streams with Ammonite: a syntax comparison</title>
      <link>http://ag91.github.io/blog/2023/06/02/fs2-vs-zio-streams-with-ammonite-a-syntax-comparison</link>
      <description><![CDATA[]]></description>
      <pubDate>2023-06-03</pubDate>
      <guid>http://ag91.github.io/blog/2023/06/02/fs2-vs-zio-streams-with-ammonite-a-syntax-comparison</guid>
    </item>
    <item>
      <title>org-blk-uri a little module to insert a file or url as an Org Mode src block</title>
      <link>http://ag91.github.io/blog/2023/05/25/org-blk-uri-a-little-module-to-insert-a-file-or-url-as-an-org-mode-src-block</link>
      <description><![CDATA[]]></description>
      <pubDate>2023-05-25</pubDate>
      <guid>http://ag91.github.io/blog/2023/05/25/org-blk-uri-a-little-module-to-insert-a-file-or-url-as-an-org-mode-src-block</guid>
    </item>
    <item>
      <title>Moldable Emacs: what is the public API of this Elisp buffer?</title>
      <link>http://ag91.github.io/blog/2023/03/24/moldable-emacs-what-is-the-public-api-of-this-elisp-buffer</link>
      <description><![CDATA[]]></description>
      <pubDate>2023-03-24</pubDate>
      <guid>http://ag91.github.io/blog/2023/03/24/moldable-emacs-what-is-the-public-api-of-this-elisp-buffer</guid>
    </item>
    <item>
      <title>Doctest.el or testing your pure Elisp functions in your docstring</title>
      <link>http://ag91.github.io/blog/2023/03/20/doctestel-or-testing-your-pure-elisp-functions-in-your-docstring</link>
      <description><![CDATA[]]></description>
      <pubDate>2023-03-20</pubDate>
      <guid>http://ag91.github.io/blog/2023/03/20/doctestel-or-testing-your-pure-elisp-functions-in-your-docstring</guid>
    </item>
  </channel>
</rss>